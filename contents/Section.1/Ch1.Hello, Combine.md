# Chatper1. Hello, Combine!

애플의 말에 따르면 

> **Combine 프레임워크**는 앱이 이벤트를 처리하는 방법에 대한 **선언적인 접근 방식**을 제공합니다. 잠재적으로 여러 대의원 콜백이나 완료 핸들러 클로저를 구현하는 대신, 주어진 이벤트 소스에 대한 **단일 처리 체인**을 만들 수 있습니다. 체인의 각 부분은 이전 단계에서 받은 요소에 대해 별도의 작업을 수행하는 결합 연산자입니다.

Combine이 해결하는 문제와 그렇게 하는 데 사용하는 도구에 대해 조금 배우는 데 약간의 시간이 걸릴 것입니다.

## Asynchrounous Programming

간단한 단일 스레드 언어로, 프로그램은 순차적으로 한 줄씩 실행한다. 

예) 의사 코드:

```swift
begin
  var name = "Tom"
  print(name)
  name += " Harding"
  print(name)
end
```

동기 코드는 이해하기 쉽고 특히 데이터 상태에 대해 논쟁하기 쉽습니다. 

단일 실행 스레드를 사용하면 데이터의 **현재 상태가 무엇인지 항상 확신할 수 있습니다.** 

위의 예에서, 첫 번째로 "Tom"이 출력되고 두 번째로는 항상 "Tome Harding"이 출력될 것이라는 것을 알고 있습니다.

이제 Swift 및 UIKit에서 실행되는 iOS 앱과 같이 비동기 이벤트 기반 UI 프레임워크를 실행하는 다중 스레드 언어로 프로그램을 작성했다고 상상해 보자.

```swift
--- Thread 1 ---
begin
  var name = "Tom"
  print(name)
--- Thread 2 ---
name = "Billy Bob"
--- Thread 1 ---
  name += " Harding"
  print(name)
end
```

여기서, 코드는 name의 값을 "Tom"으로 설정한 다음 이전과 마찬가지로 "Harding"을 추가합니다. 하지만 다른 스레드가 동시에 실행될 수 있기 때문에, 프로그램의 다른 부분이 두 이름의 돌연변이 사이에서 실행되어 "Billy Bob"과 같은 다른 값으로 설정할 수 있습니다.

코드가 다른 코어에서 동시에 실행될 때, 코드의 어느 부분이 공유 상태를 먼저 수정할 것인지 말하기는 어렵다.

위의 예시에서 "Thread 2"에서 실행되는 코드는 다음과 같습니다:

• 원래 코드와 다른 CPU 코어에서 정확히 동시에 실행합니다.

• `name += "Harding"` 직전에 실행되므로, 원래 값 "Tom" 대신 "Billy Bob"을 얻습니다.

이 코드를 실행할 때 정확히 일어나는 일은 시스템 부하에 따라 다르며, 프로그램을 실행할 때마다 다른 결과를 볼 수 있습니다.

비동기 동시 코드를 실행하면 앱에서 가변 상태를 관리하는 것이 로드된 작업이 됩니다.

## Foundation and UIKit/AppKit
Apple은 수년 동안 그들의 플랫폼을 위한 비동기 프로그래밍을 개선하고 있다. 그들은 비동기 코드를 만들고 실행하는 데 다른 시스템 수준에서 사용할 수 있는 몇 가지 메커니즘을 만들었습니다. 모바일 앱을 작성하는 데 매우 근본적이기 때문에 다시 생각하지 않고 프로젝트에서 이것들을 사용했을 것입니다.

* **Notification Center**
* **Delegate pattern**
* **GCD(Grand Central Dispatch) & Operations**
* **Closures**

대부분의 일반적인 코드는 일부 작업을 비동기적으로 수행하고 모든 UI 이벤트는 본질적으로 비동기적이기 때문에, 앱 코드 전체가 실행될 순서에 대해 가정하는 것은 불가능합니다.

그럼에도 불구하고, 좋은 비동기 프로그램을 작성하는 것은 가능하다. 하지만 불행하게도, 비동기 코드와 자원 공유는 재현, 추적 및 궁극적으로 해결하기 어려운 문제를 일으킬 수 있다.

확실히, 이러한 문제의 원인 중 하나는 견고하고 실제 앱이 각각 고유한 인터페이스를 갖춘 모든 종류의 비동기 API를 사용할 가능성이 높다는 사실입니다.