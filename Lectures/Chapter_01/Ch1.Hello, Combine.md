# Chatper1. Hello, Combine!

애플의 말에 따르면 

> **Combine 프레임워크**는 앱이 이벤트를 처리하는 방법에 대한 **선언적인 접근 방식**을 제공합니다. 잠재적으로 여러 대의원 콜백이나 완료 핸들러 클로저를 구현하는 대신, 주어진 이벤트 소스에 대한 **단일 처리 체인**을 만들 수 있습니다. 체인의 각 부분은 이전 단계에서 받은 요소에 대해 별도의 작업을 수행하는 결합 연산자입니다.

Combine이 해결하는 문제와 그렇게 하는 데 사용하는 도구에 대해 조금 배우는 데 약간의 시간이 걸릴 것입니다.

## Asynchrounous Programming

간단한 단일 스레드 언어로, 프로그램은 순차적으로 한 줄씩 실행한다. 

예) 의사 코드:

```swift
begin
  var name = "Tom"
  print(name)
  name += " Harding"
  print(name)
end
```

동기 코드는 이해하기 쉽고 특히 데이터 상태에 대해 논쟁하기 쉽습니다. 

단일 실행 스레드를 사용하면 데이터의 **현재 상태가 무엇인지 항상 확신할 수 있습니다.** 

위의 예에서, 첫 번째로 "Tom"이 출력되고 두 번째로는 항상 "Tome Harding"이 출력될 것이라는 것을 알고 있습니다.

이제 Swift 및 UIKit에서 실행되는 iOS 앱과 같이 비동기 이벤트 기반 UI 프레임워크를 실행하는 다중 스레드 언어로 프로그램을 작성했다고 상상해 보자.

```swift
--- Thread 1 ---
begin
  var name = "Tom"
  print(name)
--- Thread 2 ---
name = "Billy Bob"
--- Thread 1 ---
  name += " Harding"
  print(name)
end
```

여기서, 코드는 name의 값을 "Tom"으로 설정한 다음 이전과 마찬가지로 "Harding"을 추가합니다. 하지만 다른 스레드가 동시에 실행될 수 있기 때문에, 프로그램의 다른 부분이 두 이름의 돌연변이 사이에서 실행되어 "Billy Bob"과 같은 다른 값으로 설정할 수 있습니다.

코드가 다른 코어에서 동시에 실행될 때, 코드의 어느 부분이 공유 상태를 먼저 수정할 것인지 말하기는 어렵다.

위의 예시에서 "Thread 2"에서 실행되는 코드는 다음과 같습니다:

• 원래 코드와 다른 CPU 코어에서 정확히 동시에 실행합니다.

• `name += "Harding"` 직전에 실행되므로, 원래 값 "Tom" 대신 "Billy Bob"을 얻습니다.

이 코드를 실행할 때 정확히 일어나는 일은 시스템 부하에 따라 다르며, 프로그램을 실행할 때마다 다른 결과를 볼 수 있습니다.

비동기 동시 코드를 실행하면 앱에서 가변 상태를 관리하는 것이 로드된 작업이 됩니다.

## Foundation and UIKit/AppKit
Apple은 수년 동안 그들의 플랫폼을 위한 비동기 프로그래밍을 개선하고 있다. 그들은 비동기 코드를 만들고 실행하는 데 다른 시스템 수준에서 사용할 수 있는 몇 가지 메커니즘을 만들었습니다. 모바일 앱을 작성하는 데 매우 근본적이기 때문에 다시 생각하지 않고 프로젝트에서 이것들을 사용했을 것입니다.

* **Notification Center**
* **Delegate pattern**
* **GCD(Grand Central Dispatch) & Operations**
* **Closures**

대부분의 일반적인 코드는 일부 작업을 비동기적으로 수행하고 모든 UI 이벤트는 본질적으로 비동기적이기 때문에, 앱 코드 전체가 실행될 순서에 대해 가정하는 것은 불가능합니다.

그럼에도 불구하고, 좋은 비동기 프로그램을 작성하는 것은 가능하다. 하지만 불행하게도, 비동기 코드와 자원 공유는 재현, 추적 및 궁극적으로 해결하기 어려운 문제를 일으킬 수 있다.

확실히, 이러한 문제의 원인 중 하나는 견고하고 실제 앱이 각각 고유한 인터페이스를 갖춘 모든 종류의 비동기 API를 사용할 가능성이 높다는 사실입니다.

![1-1](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-1.png?raw=true)

Combine은 비동기 프로그래밍 세계의 혼란에 더 많은 질서를 가져오는 데 도움이 되는 Swift 생태계에 새로운 언어를 도입하는 것을 목표로 한다.

Apple은 Combine의 API를 Foundation 프레임워크에 깊이 통합했기 때문에 타이머, NotificationCenter 및 **Core Data**와 같은 핵심 프레임워크는 이미 언어를 구사합니다. 운 좋게도, Combine은 또한 당신의 코드에 통합하기가 매우 쉽습니다.

마지막으로, Apple은 Combine과 쉽게 통합할 수 있도록 놀라운 새로운 UI 프레임워크인 SwiftUI를 설계했다.

Apple이 Combine으로 리액티브 프로그래밍에 얼마나 전념하고 있는지에 대한 아이디어를 제공하기 위해, 다음은 Combine이 시스템 계층 구조에서 어디에 있는지 보여주는 간단한 다이어그램입니다:

![1-2](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-2.png?raw=true)

대안에서 SwiftUI에 이르기까지 다양한 시스템 프레임워크는 결합에 의존하며 "전통적인" API의 대안으로 결합 통합을 제공합니다.

Combine은 Apple 프레임워크이기 때문에, 타이머나 NotificationCenter와 같이 잘 테스트되고 견고한 API의 역할을 없애는 것을 목표로 하지 않는다. 그 재단 유형들은 여전히 존재하며 그들의 역할을 하고 있다. 대신, Combine은 그들과 통합되어 서로 비동기적으로 대화하려는 앱의 모든 유형이 새롭고 보편적인 언어를 통해 그렇게 할 수 있도록 합니다.

