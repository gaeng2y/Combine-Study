# Chatper1. Hello, Combine!

애플의 말에 따르면 

> **Combine 프레임워크**는 앱이 이벤트를 처리하는 방법에 대한 **선언적인 접근 방식**을 제공합니다. 잠재적으로 여러 대의원 콜백이나 완료 핸들러 클로저를 구현하는 대신, 주어진 이벤트 소스에 대한 **단일 처리 체인**을 만들 수 있습니다. 체인의 각 부분은 이전 단계에서 받은 요소에 대해 별도의 작업을 수행하는 결합 연산자입니다.

Combine이 해결하는 문제와 그렇게 하는 데 사용하는 도구에 대해 조금 배우는 데 약간의 시간이 걸릴 것입니다.

## Asynchrounous Programming

간단한 단일 스레드 언어로, 프로그램은 순차적으로 한 줄씩 실행한다. 

예) 의사 코드:

```swift
begin
  var name = "Tom"
  print(name)
  name += " Harding"
  print(name)
end
```

동기 코드는 이해하기 쉽고 특히 데이터 상태에 대해 논쟁하기 쉽습니다. 

단일 실행 스레드를 사용하면 데이터의 **현재 상태가 무엇인지 항상 확신할 수 있습니다.** 

위의 예에서, 첫 번째로 "Tom"이 출력되고 두 번째로는 항상 "Tome Harding"이 출력될 것이라는 것을 알고 있습니다.

이제 Swift 및 UIKit에서 실행되는 iOS 앱과 같이 비동기 이벤트 기반 UI 프레임워크를 실행하는 다중 스레드 언어로 프로그램을 작성했다고 상상해 보자.

```swift
--- Thread 1 ---
begin
  var name = "Tom"
  print(name)
--- Thread 2 ---
name = "Billy Bob"
--- Thread 1 ---
  name += " Harding"
  print(name)
end
```

여기서, 코드는 name의 값을 "Tom"으로 설정한 다음 이전과 마찬가지로 "Harding"을 추가합니다. 하지만 다른 스레드가 동시에 실행될 수 있기 때문에, 프로그램의 다른 부분이 두 이름의 돌연변이 사이에서 실행되어 "Billy Bob"과 같은 다른 값으로 설정할 수 있습니다.

코드가 다른 코어에서 동시에 실행될 때, 코드의 어느 부분이 공유 상태를 먼저 수정할 것인지 말하기는 어렵다.

위의 예시에서 "Thread 2"에서 실행되는 코드는 다음과 같습니다:

• 원래 코드와 다른 CPU 코어에서 정확히 동시에 실행합니다.

• `name += "Harding"` 직전에 실행되므로, 원래 값 "Tom" 대신 "Billy Bob"을 얻습니다.

이 코드를 실행할 때 정확히 일어나는 일은 시스템 부하에 따라 다르며, 프로그램을 실행할 때마다 다른 결과를 볼 수 있습니다.

비동기 동시 코드를 실행하면 앱에서 가변 상태를 관리하는 것이 로드된 작업이 됩니다.

## Foundation and UIKit/AppKit
Apple은 수년 동안 그들의 플랫폼을 위한 비동기 프로그래밍을 개선하고 있다. 그들은 비동기 코드를 만들고 실행하는 데 다른 시스템 수준에서 사용할 수 있는 몇 가지 메커니즘을 만들었습니다. 모바일 앱을 작성하는 데 매우 근본적이기 때문에 다시 생각하지 않고 프로젝트에서 이것들을 사용했을 것입니다.

* **Notification Center**
* **Delegate pattern**
* **GCD(Grand Central Dispatch) & Operations**
* **Closures**

대부분의 일반적인 코드는 일부 작업을 비동기적으로 수행하고 모든 UI 이벤트는 본질적으로 비동기적이기 때문에, 앱 코드 전체가 실행될 순서에 대해 가정하는 것은 불가능합니다.

그럼에도 불구하고, 좋은 비동기 프로그램을 작성하는 것은 가능하다. 하지만 불행하게도, 비동기 코드와 자원 공유는 재현, 추적 및 궁극적으로 해결하기 어려운 문제를 일으킬 수 있다.

확실히, 이러한 문제의 원인 중 하나는 견고하고 실제 앱이 각각 고유한 인터페이스를 갖춘 모든 종류의 비동기 API를 사용할 가능성이 높다는 사실입니다.

![1-1](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-1.png?raw=true)

Combine은 비동기 프로그래밍 세계의 혼란에 더 많은 질서를 가져오는 데 도움이 되는 Swift 생태계에 새로운 언어를 도입하는 것을 목표로 한다.

Apple은 Combine의 API를 Foundation 프레임워크에 깊이 통합했기 때문에 타이머, NotificationCenter 및 **Core Data**와 같은 핵심 프레임워크는 이미 언어를 구사합니다. 운 좋게도, Combine은 또한 당신의 코드에 통합하기가 매우 쉽습니다.

마지막으로, Apple은 Combine과 쉽게 통합할 수 있도록 놀라운 새로운 UI 프레임워크인 SwiftUI를 설계했다.

Apple이 Combine으로 리액티브 프로그래밍에 얼마나 전념하고 있는지에 대한 아이디어를 제공하기 위해, 다음은 Combine이 시스템 계층 구조에서 어디에 있는지 보여주는 간단한 다이어그램입니다:

![1-2](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-2.png?raw=true)

대안에서 SwiftUI에 이르기까지 다양한 시스템 프레임워크는 결합에 의존하며 "전통적인" API의 대안으로 결합 통합을 제공합니다.

Combine은 Apple 프레임워크이기 때문에, 타이머나 NotificationCenter와 같이 잘 테스트되고 견고한 API의 역할을 없애는 것을 목표로 하지 않는다. 그 재단 유형들은 여전히 존재하며 그들의 역할을 하고 있다. 대신, Combine은 그들과 통합되어 서로 비동기적으로 대화하려는 앱의 모든 유형이 새롭고 보편적인 언어를 통해 그렇게 할 수 있도록 합니다.

## Foundation of Combine

첫 번째 "현대적인" 반응형 솔루션은 2009년 마이크로소프트의 팀이 .NET을 위한 **Reactive Extension(Rx.NET)**이라는 라이브러리를 출시했을 때 크게 나왔다. 

마이크로소프트는 2012년에 Rx.NET 구현을 오픈 소스로 만들었고, 그 이후로 많은 다른 언어들이 그 개념을 사용하기 시작했다. 현재, RxJS, RxKotlin, RxScala, RxPHP 등과 같은 Rx 표준의 많은 포트가 있습니다.

Apple 플랫폼의 경우, Rx 표준을 구현하는 RxSwift, Rx에서 영감을 받은 ReactiveSwift, 사용자 지정 구현인 Interstellar 등과 같은 여러 타사 반응형 프레임워크가 있었습니다.

Combine은 Reactive Streams라고 불리는 Rx와는 다르지만 유사한 표준을 구현합니다. 리액티브 스트림은 Rx와 몇 가지 주요 차이점이 있지만, 둘 다 대부분의 핵심 개념에 동의한다.

이전에 위에서 언급한 프레임워크 중 하나 또는 다른 프레임워크를 사용하지 않았다면 걱정하지 마세요. 지금까지, 반응형 프로그래밍은 애플 플랫폼, 특히 Swift의 다소 틈새 개념이었다.

## Combine basics

광범위한 스트로크에서, Combine을 동작하게 하는 세 가지의 키는 Publishers, Operators 및 Subscribers이다. 물론, 다른 요소들도 있지만 저 세가지가 없으면 동작을 할 수 없다.

## Publishers

Publishers는 subsriber와 같은 하나 이상의 이해 관계자에게 시간이 지남에 따라 값을 방출할 수 있는 유형입니다. 수학 계산, 네트워킹 또는 사용자 이벤트 처리를 포함하여 거의 모든 것이 될 수 있는 publisher의 내부 논리에 관계없이, 모든 publisher는 다음 세 가지 유형의 여러 이벤트를 방출할 수 있습니다.

1. Publisher의 제네릭 `Output` 타입의 출력 값.
2. 성공적인 completion
3. Publisher의 `Failure` 타입의 에러가 포함된 completion

Publisher는 0개 이상의 출력 값을 방출할 수 있으며, 성공적으로 완료되거나 실패로 인해 완료되면 다른 이벤트를 방출하지 않습니다.

Int 값을 방출하는 Publisher가 타임라인에서 시각화된 것처럼 보일 수 있는 방법은 다음과 같습니다:

![1-3](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-3.png?raw=true)

파란색 상자는 타임라인에서 주어진 시간에 방출되는 값을 나타내며, 숫자는 방출된 값을 나타낸다. 다이어그램의 오른쪽에 보이는 것과 같은 수직선은 성공적인 스트림 완료를 나타냅니다.

세 가지 가능한 이벤트의 간단한 계약은 너무 보편적이어서 프로그램에서 모든 종류의 동적 데이터를 나타낼 수 있습니다. 그렇기 때문에 숫자 크런치, 네트워크 호출, 사용자 제스처에 반응 또는 화면에 데이터 표시 여부에 관계없이 게시자 결합을 사용하여 앱의 모든 작업을 해결할 수 있습니다.

Delegate를 추가하거나 completion 콜백을 주입하든, 항상 도구 상자에서 당면한 작업에 적합한 도구를 찾는 대신 Publisher를 사용할 수 있습니다.

Publisher의 가장 좋은 기능 중 하나는 오류 처리가 내장되어 있다는 것입니다. 오류 처리는 당신이 원한다면 마지막에 선택적으로 추가하는 것이 아닙니다.

Publisher 프로토콜은 이전에 다이어그램에서 알 수 있듯이 두 가지 유형에 걸쳐 일반적입니다.

• Publisher.Output은 Publisher의 출력 값 유형입니다. Publisher가 Int로 특화되어 있다면, 문자열이나 날짜 값을 절대 방출할 수 없습니다.

• Publisher.Failure는 Publisher가 실패할 경우 던질 수 있는 오류 유형입니다. Publisher가 절대 실패할 수 없다면, `Never` 실패 유형을 사용하여 지정하십시오.

주어진 Publisher를 구독할 때, 당신은 그것으로부터 어떤 가치를 기대할 수 있고 어떤 오류가 실패할 수 있는지 알 수 있습니다.

## Operators

Operator는 동일하거나 새 Publisher를 반환하는 `Publisher` 프로토콜에 선언된 방법입니다. 그것은 당신이 많은 Operator를 차례로 불러 효과적으로 함께 묶을 수 있기 때문에 매우 유용합니다.

"Operator"라고 불리는 이 방법들은 고도로 분리되고 구성 가능하기 때문에, Opertaor들은 단일 구독 실행에 대해 매우 복잡한 논리를 구현하기 위해 결합될 수 있다.

Operator가 퍼즐 조각처럼 단단히 맞추는 것은 매혹적이다. 출력이 다음 입력 유형과 일치하지 않으면 실수로 잘못된 순서로 넣거나 함께 맞출 수 없습니다:

![1-4](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-4.png?raw=true)


명확한 결정론적 방식으로, 올바른 입출력 유형 및 내장 오류 처리와 함께 비동기 추상화된 각 작업의 순서를 정의할 수 있습니다. 

추가로, Operator는 항상 업스트림과 다운스트림이라고 불리는 입력과 출력을 가지고 있습니다. 이를 통해 공유 상태(이전에 논의한 핵심 문제 중 하나)를 피할 수 있습니다.

Operator는 이전 Operator로부터 받은 데이터 작업에 집중하고 체인의 다음 데이터로 출력을 제공합니다. 이것은 비동기적으로 실행되는 다른 어떤 코드도 작업 중인 데이터를 "jump in"하고 변경할 수 없다는 것을 의미합니다.

## Subscribers

마지막으로, 구독 체인의 끝에 도착합니다: 모든 구독은 Subscriber로 끝납니다. Subscriber는 일반적으로 방출된 출력 또는 완료 이벤트로 "무언가"를 수행합니다.

![1-5](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-5.png?raw=true)

현재, Combine은 데이터 스트림 작업을 간단하게 만드는 두 개의 내장 Subscriber를 제공합니다:

* **Sink** Subscriber를 사용하면 output과 completion을 받을 코드로 클로저를 제공할 수 있습니다. 거기에서, 당신은 받은 이벤트로 당신의 마음이 원하는 모든 것을 할 수 있습니다.
* **Assign** Subscriber를 사용하면 사용자 지정 코드 없이 결과 출력을 데이터 모델이나 UI 컨트롤의 일부 속성에 바인딩하여 key path를 통해 화면에 직접 데이터를 표시할 수 있습니다.

데이터에 대한 다른 요구 사항이 있다면, publisher를 만드는 것보다 커스텀 subscriber를 만드는 것이 훨씬 쉽습니다. Combine은 워크숍이 작업에 적합한 도구를 제공하지 않을 때마다 자신만의 맞춤형 도구를 만들 수 있는 매우 간단한 프로토콜 세트를 사용합니다.

## Subscriptions

> 참고: 이 책은 구독이라는 용어를 사용하여 Combine의 `Subscription` 프로토콜과 준수 객체뿐만 아니라 publisher, operator 및 subscriber의 전체 체인을 모두 설명합니다.

구독이 끝날 때 subscriber를 추가하면, 체인 시작 부분에서 publisher를 끝까지 "활성화"합니다. 이것은 기억해야 할 흥미스럽지만 중요한 세부 사항입니다. publisher는 잠재적으로 출력을 받을 subscriber가 없는 경우 값을 방출하지 않습니다.

구독은 자체 사용자 지정 코드와 오류 처리로 비동기 이벤트 체인을 한 번만 선언한 다음 다시 생각할 필요가 없다는 점에서 훌륭한 개념입니다.

완전히 결합하면 구독을 통해 전체 앱의 논리를 설명할 수 있으며 완료되면 데이터가 푸시 또는 풀거나 이 개체를 다시 호출할 필요 없이 시스템이 모든 것을 실행하도록 하십시오.

![1-6](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-6.png?raw=true)

구독 코드가 성공적으로 컴파일되고 사용자 지정 코드에 논리 문제가 없으면 완료됩니다! 구독은 사용자 제스처, 타이머가 꺼지거나 다른 것이 게시자 중 한 명을 깨울 때마다 비동기적으로 "발사"됩니다.

더 나아가, Combine이 제공하는 `Cancellable`이라는 프로토콜 덕분에 구독을 특별히 메모리 관리할 필요가 없다는 것입니다.

시스템에서 제공하는 두 Subscriber(sink, assign) 모두 Cancellable을 준수하며, 이는 구독 코드(예: 전체 publisher, operator 및 subscriber 호출 체인)가 Cancellable 객체를 반환한다는 것을 의미합니다. 메모리에서 해당 객체를 해제할 때마다, 전체 구독을 취소하고 메모리에서 리소스를 해제합니다.

즉, 예를 들어 뷰 컨트롤러의 속성에 저장하여 구독 수명을 쉽게 "바인딩" 할 수 있습니다. 이렇게 하면, 사용자가 뷰 스택에서 뷰 컨트롤러를 해제할 때마다 속성을 초기화하고 구독을 취소할 수 있습니다.

또는 이 프로세스를 자동화하려면, 유형에 [AnyCancellable] 컬렉션 속성을 넣고 원하는 만큼 구독을 던질 수 있습니다. 속성이 메모리에서 해제되면 모두 자동으로 취소되고 해제됩니다.

## What's the benefit of Combine code over "standard" code?

반드시 Combine을 사용하지 않고도 좋은 앱을 만들 수 있습니다. Core Data, URLSession 또는 UIKit 없이도 최고의 앱을 만들 수 있습니다. 하지만 이러한 프레임워크를 사용하는 것은 그 추상화를 직접 만드는 것보다 더 편리하고 안전하며 효율적이다.

Combine(및 기타 시스템 프레임워크)은 비동기 코드에 또 다른 추상화를 추가하는 것을 목표로 합니다. 시스템 수준에서 또 다른 수준의 추상화는 잘 테스트된 더 엄격한 Combine과 오래 지속되는 지원을 위한 안전한 기술을 의미합니다.

Combine이 프로젝트에 적합한지 아닌지를 결정하는 것은 당신에게 달려 있지만, 아직 고려하지 않았을 수도 있는 몇 가지 "프로" 이유는 다음과 같습니다:

* Combine은 시스템 수준에 통합되어 있다. 즉, Combine 자체는 공개적으로 사용할 수 없는 언어 기능을 사용하여 직접 구축할 수 없는 API를 제공합니다.
* Delegate, IBAction 또는 클로저를 통한 **"오래된"** 스타일의 비동기 코드는 처리해야 하는 버튼이나 제스처의 각 사례에 대한 커스텀 코드를 작성하도록 강요합니다. 그것은 테스트를 작성할 수 있는 많은 커스텀 코드이다. Combine은 코드의 모든 비동기 작업을 이미 잘 테스트된 "operator"로 추상화합니다.
* 모든 비동기 조각이 동일한 인터페이스(Publisher)를 사용할 때 구성과 재사용성이 매우 강력해집니다.
* Combine의 operator는 높은 구성 가능성이 있다. 새 것을 만들어야 한다면, 그 새로운 operator는 나머지 Combine과 즉시 플러그 앤 플레이할 것이다.
* 비동기 코드를 테스트하는 것은 보통 동기 코드를 테스트하는 것보다 더 복잡하다. 그러나 Combine을 사용하면 비동기 운영자가 이미 테스트되었으며, 비즈니스 로직을 테스트하기만 하면 됩니다. 즉, 구독이 예상 결과를 출력하는지 일부 입력을 제공하고 테스트할 수 있습니다.

보시다시피, 대부분의 혜택은 안전과 편리함을 중심으로 합니다. 프레임워크가 애플에서 왔다는 사실과 결합하여, Combine 코드 작성에 투자하는 것은 유망해 보인다.

## App architecture

이 질문은 이미 머릿속에서 알람을 울릴 가능성이 높기 때문에, Combine을 사용하면 기존 코드와 앱 아키텍처를 어떻게 바꿀지 살펴보세요.

Combine은 앱을 구성하는 방식에 영향을 미치는 프레임워크가 아닙니다. Combine은 비동기 데이터 이벤트 및 통합 통신 계약을 다룹니다. 예를 들어 프로젝트의 책임을 분리하는 방법은 변경되지 않습니다.

MVC(Model-View-Controller) 앱에서 Combine을 사용할 수 있으며, MVVM(Model-View-ViewModel) 코드, VIPER 등에서 사용할 수 있습니다.

이것은 일찍 이해하는 데 중요한 Combine을 채택하는 주요 측면 중 하나입니다. 코드베이스에서 개선하려는 부분에서만 코드를 반복적이고 선택적으로 결합할 수 있습니다. 그것은 당신이 해야 할 "전부 아니면 전무" 선택이 아닙니다.

데이터 모델을 변환하거나 네트워킹 계층을 조정하거나 기존 기능을 그대로 유지하면서 앱에 추가하는 새 코드에서만 Combine을 사용하는 것으로 시작할 수 있습니다.

Combine과 SwiftUI를 동시에 채택한다면 약간 다른 이야기입니다. 이 경우, MVC 아키텍처에서 C를 떨어뜨리는 것은 정말 말이 된다. 하지만 그것은 Combine과 SwiftUI를 동시에 사용한 덕분입니다. 그 둘은 같은 방에 있을 때 단순히 불타고 있습니다.

뷰 컨트롤러는 Combine/SwiftUI 팀을 상대로 기회가 없습니다. 데이터 모델에서 뷰에 이르기까지 반응형 프로그래밍을 사용할 때, 뷰를 제어하기 위해 특수 컨트롤러가 필요하지 않습니다:

![1-7](https://github.com/gaeng2y/Combine-Study/blob/main/Lectures/Chapter_01/1-7.png?raw=true)

## Book projects

이 책에서, 당신은 먼저 개념으로 시작하고 수많은 operator를 배우고 시험해 볼 것입니다.

다른 시스템 프레임워크와 달리, Playground의 고립된 맥락에서 Combine으로 꽤 성공적으로 작업할 수 있습니다.

Xcode Playground에서 배우면 주어진 장을 진행하고 Xcode 콘솔에서 결과를 즉시 볼 때 쉽게 앞으로 나아가고 빠르게 실험할 수 있습니다.

## Key points

* Combine은 시간이 지남에 따라 비동기 이벤트를 처리하기 위한 선언적이고 반응적인 프레임워크이다.
* 그것은 비동기 프로그래밍을 위한 도구 통합, 가변 상태 처리 및 시작 팀 플레이어를 처리하는 오류와 같은 기존 문제를 해결하는 것을 목표로 한다.
* Combine은 세 가지 주요 유형을 중심으로 진행됩니다: 시간이 지남에 따라 이벤트를 방출하는 **Publisher**, **Operator**는 업스트림 이벤트를 비동기적으로 처리 및 조작하며, **Subscriber**는 결과를 소비하고 유용한 일을 합니다.




























